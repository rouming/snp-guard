# SnpGuard API Documentation

## Overview

SnpGuard provides two main API interfaces:

1. **Attestation API**: Used by guest VMs to perform attestation (HTTPS + Protobuf, REST)
2. **Management API**: Used by the web UI/automation for managing attestation records (HTTPS + Protobuf/JSON)

## Attestation API

The Attestation API uses HTTPS with Protocol Buffers for secure, efficient communication.

### Base URL

```
https://your-attestation-service.com
```

### Content-Type

All attestation endpoints use:
```
Content-Type: application/x-protobuf
```

### Endpoints

#### GET `/v1/keys/ingestion/public`

Get the ingestion public key for encrypting unsealing private keys.

**Request**: No body required

**Response** (200 OK):
- Content-Type: `application/x-pem-file`
- Body: PEM-encoded X25519 public key

**Error Responses**:
- `500 Internal Server Error`: Server error retrieving key

**Example** (using curl):
```bash
curl -X GET https://attest.example.com/v1/keys/ingestion/public \
  --output ingestion.pub
```

**Note**: This endpoint is public (no authentication required) as the public key is meant to be shared for encryption purposes.

#### POST `/v1/attest/nonce`

Request a random 64-byte nonce for attestation report generation.

**Request**:
```protobuf
message NonceRequest {}
```

**Response** (200 OK):
```protobuf
message NonceResponse {
  bytes nonce = 1;  // Exactly 64 bytes of random data
}
```

**Error Responses**:
- `400 Bad Request`: Invalid protobuf message
- `500 Internal Server Error`: Server error generating nonce

**Example** (using curl):
```bash
# Note: This is for demonstration. In practice, use the client tool.
echo -n -e '\x0a\x05\x67\x75\x65\x73\x74' | \
  curl -X POST https://attest.example.com/attestation/nonce \
    -H "Content-Type: application/x-protobuf" \
    --data-binary @- \
    --output nonce.bin
```

#### POST `/v1/attest/report`

Verify an attestation report, unseal VMK from sealed blob, and return session-encrypted VMK if successful.

**Request**:
```protobuf
message AttestationRequest {
  bytes report_data = 1;           // SEV-SNP attestation report (binary, 1184 bytes)
  bytes server_nonce = 2;           // Server nonce (64 bytes) used for binding
  bytes client_pub_bytes = 3;       // X25519 Session Public Key (32 bytes)
  bytes sealed_blob = 4;           // HPKE-encrypted VMK blob [Encapped_Key (32 bytes) || Ciphertext]
}
```

**Response** (200 OK):
```protobuf
message AttestationResponse {
  bool success = 1;                // true if attestation passed
  bytes encapped_key = 2;           // HPKE Encapsulated Key (32 bytes) - Server Ephemeral Pub
  bytes ciphertext = 3;             // Session-encrypted VMK (HPKE ciphertext)
  string error_message = 4;         // Error description (if !success)
}
```

**Verification Process** (in order):

1. Validate request fields (server_nonce: 64 bytes, client_pub_bytes: 32 bytes, sealed_blob: >= 32 bytes)
2. Parse report with sev call from bytes
3. Verify stateless nonce from the report.report_data - must be generated by our code, signed with ephemeral secret, not expired (within +/- 60s window)
4. Verify hash binding - SHA512(server_nonce || client_pub_bytes) must match report.report_data (64 bytes)
5. Find attestation record by report.image_id, report.id_key_digest, report.auth_key_digest
6. Check if record is not disabled
7. Check TCB (bootloader, TEE, SNP, microcode versions meet minimum requirements)
8. Check VMPL (must be 0 for kernel level)
9. Verify report certs (verify report signature using integrated `snpguest` which fetches AMD certificates from KDS)
10. Reencrypt sealed blob (unseal VMK using unsealing private key, reseal for client session)
11. Return success with encapped_key and ciphertext if all checks pass

**Security Notes**:
- Nonce verification ensures the nonce was legitimately issued by the server before validating the binding hash
- The binding hash binds the attestation report to the specific session, preventing replay attacks
- Both verifications must pass for attestation to proceed

**Error Responses**:
- `400 Bad Request`: Invalid protobuf message or report too short
- `500 Internal Server Error`: Server error during verification

**Example** (using curl):
```bash
# Generate report first (on guest VM)
snpguest report report.bin nonce.bin

# Send for verification
cat report.bin | \
  curl -X POST https://attest.example.com/attestation/verify \
    -H "Content-Type: application/x-protobuf" \
    --data-binary @- \
    --output response.bin
```

## Management API (HTTPS)

Authentication:
- Master password (Diceware, printed once, Argon2 hash stored)
- Bearer tokens for automation (create/revoke via web UI Tokens page)

Endpoints (protobuf payloads, `application/x-protobuf`):
- `GET/POST /v1/records` (list/create)
- `GET/DELETE /v1/records/{id}` (view/delete)
- `POST /v1/records/{id}/enable`, `/disable`
- `GET/POST /v1/tokens`, `POST /v1/tokens/{id}/revoke`

**Note**: Attestation records are immutable. To make changes, delete the old record and create a new one.

### Endpoints

#### GET `/`

List all attestation records.

**Response**: HTML page with table of records

#### GET `/create`

Display form for creating a new attestation record.

**Response**: HTML form

#### POST `/create`

Create a new attestation record.

**Request**: `multipart/form-data` with:
- `os_name` (text): Name of the OS/VM
- `unsealing_private_key` (text): Unsealing private key (PEM-encoded, will be encrypted)
- `firmware` (file): Firmware image (<10 MB)
- `kernel` (file): Kernel binary (<50 MB)
- `initrd` (file): Initrd image (<50 MB)
- `kernel_params` (text): Kernel command-line parameters
- `vcpus` (text): Number of vCPUs
- `vcpu_type` (text): EPYC, EPYC-Milan, EPYC-Rome, or EPYC-Genoa
- `service_url` (text): HTTPS URL of attestation service

**Note**: ID Block Key and Auth Block Key are now automatically generated by the server.

**Response**: Redirect to `/` on success, error page on failure

#### GET `/view/:id`

View an attestation record (read-only).

**Parameters**:
- `id`: UUID of the attestation record

**Response**: HTML page displaying record details (read-only)

**Note**: Attestation records are immutable. To make changes, delete this record and create a new one.

#### POST `/toggle/:id`

Toggle enabled/disabled status of an attestation record.

**Response**: Redirect to `/`

#### GET `/delete/:id`

Delete an attestation record.

**Response**: Redirect to `/`

#### GET `/download/:id/:file`

Download an artifact file.

**Parameters**:
- `id`: UUID of the attestation record
- `file`: Filename to download

**Available Files**:
- `id-block.bin`: ID-Block binary
- `id-auth.bin`: Auth-Block binary
- `firmware-code.fd`: Firmware image
- `vmlinuz`: Kernel binary
- `initrd.img`: Initrd image
- `kernel-params.txt`: Kernel parameters
- `artifacts.tar.gz`: Tarball with all files
- `artifacts.squashfs`: SquashFS image with all files

**Response**: Binary file download

## Protocol Buffer Definitions

See `protos/attestation.proto` for the complete protobuf schema.

## Error Handling

All endpoints return appropriate HTTP status codes:
- `200 OK`: Success
- `400 Bad Request`: Invalid request
- `401 Unauthorized`: Authentication required (management endpoints)
- `404 Not Found`: Resource not found
- `500 Internal Server Error`: Server error

Error messages in protobuf responses are human-readable strings.

## Rate Limiting

Currently, there is no rate limiting implemented. Consider adding rate limiting for production deployments.

## Security Considerations

1. **TLS**: Always use HTTPS in production. The attestation API requires TLS certificate verification.

2. **Authentication**: Use strong passwords for the management API. Consider implementing additional security measures (2FA, IP whitelisting) for production.

3. **Input Validation**: All file uploads are validated for size limits. File paths are sanitized to prevent directory traversal.

4. **Key Encryption**: Unsealing private keys are encrypted with HPKE (Hybrid Public Key Encryption) using X25519HkdfSha256, HkdfSha256, and AesGcm256 before storage. The ingestion private key must be backed up securely.
